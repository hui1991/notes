
# Vue框架设计

## 前言

最近读了一本书，书名叫《Vue.js设计与实现》（作者：霍春阳），通过这本书学习了很多，想以这本书为基础来学习Vue框架的原理。
该书内容并非“源码解读”，而是建立在作者对 Vue.js 框架设计的理解之上，以由简入繁的方式介绍如何实现 Vue.js 中的各个功能模块。

## Vue3的设计思路

Vue是一个UI框架，一个UI框架设计需要从描述，渲染，更新UI来考虑。

### 声明式UI

和声明式UI对应的命令式UI，命令式UI和声明式UI是对描述UI方式的一种划分，命令式UI在前端中就是直接操作DOM，关注过程，比如jQuery，声明式UI是描述想要UI的结果，框架会根据状态的变化自动更新UI，更容易维护。

目前理解，声明式UI其实在加了一些语法糖，来简化UI操作，声明式UI是一种趋势，目前流行的前端框架React，Vue，都是使用的声明式UI

#### Vue中声明式UI方案

- 使用与HTML标签一致的方式来描述DOM元素，如`<div></div>`
- 使用与HTML标签一致的方式来描述属性，如`<div id="app"></div>`
- 使用指令`v-bing`或者`:`来绑定动态属性，如`<div :id="dynamicedId"></div>`
- 使用指令`@`或者`v-on`来描述事件，如`<div @click='handleClick'></div>`

#### DSL（Domain-specific language）领域特定语言

DSL是针对特定应用领域的计算机语言。

Vue中的模版是一种DSL，它使用HTML结构，并通过Vue的指令（directives）和表达式（expressions）来实现数据绑定、条件渲染、事件监听等功能

### 虚拟DOM

虚拟DOM是通过javaScript对象来描述DOM结构，通过渲染器把虚拟DOM渲染成DOM，页面更新时通过对比虚拟DOM的变更来更新DOM。

虚拟DOM优势

- 页面更新时，直接操作DOM开销大，虚拟DOM可以快速的找出变化的UI，批量更新，避免频繁更新UI
- 跨平台，除了可以渲染成DOM，也可以渲染成别的平台UI

虚拟DOM难点

- 虚拟DOM的难点在于找出页面更新时变化的节点使用的diff算法

```javascript
const vnode = {
  tag: 'div',
  props: {
    onClick: () => alert('hello')
  },
  children: 'click me'
}
```

### 编译器

编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）

#### Vue中的编译器

Vue模版编译器，源代码是组件的模版，目标代码是JavaScript运行时平台上的JavaScript代码，其实就是编译成渲染函数

![2024-11-01-11-46-14](img/2024-11-01-11-46-14.png)

Vue模板编译器会首先对模板进行词法分析和语法分析，得到模版AST。接着将模版AST转换成JavaScript AST。最后根据JavaScript AST生成JavaScript代码

![2024-11-01-11-53-11](img/2024-11-01-11-53-11.png)

### 响应式编程（Reactive Programming）

响应式编程是一种编程范式，它强调数据流和变化的传播。当数据源发生变化时，系统会自动更新依赖于该数据的部分。这种自动化的更新机制，使得开发者可以更专注于数据的处理，而不用手动管理UI更新。

#### Vue的响应式系统

Vue通过数据劫持 + 观察者模式（发布订阅）来实现的响应式

### 组件

Vue 中，组件（Component）就像是一个自定义的 HTML 元素，它封装了可重用的 HTML、CSS 和 JavaScript 代码。
你可以把组件看作是一个独立的小型 Vue 实例，它拥有自己的数据、模板和生命周期。

渲染器主要负责将虚拟 DOM 渲染为真实 DOM，我们只需要使用虚拟 DOM
来描述最终呈现的内容即可。但当我们编写比较复杂的页面时，用来
描述页面结构的虚拟 DOM 的代码量会变得越来越多，或者说页面模板
会变得越来越大。这时，我们就需要组件化的能力。有了组件，我们
就可以将一个大的页面拆分为多个部分，每一个部分都可以作为单独
的组件，这些组件共同组成完整的页面。组件化的实现同样需要渲染
器的支持。

组件的作用

- 代码复用性
- 可维护性
- 可组合性
- 可测试性

组件也是通过虚拟DOM来描述的

```javascript
const MyComponent = function () {
  return{
    tag: 'div',
    props: {
      onClick: () => alert('hello')
    },
    children: 'click me'
  }
}
```

### 渲染器

渲染器用来执行渲染任务，把虚拟DOM渲染为真实的DOM元素，也是跨平台的关键

![2024-11-01-14-47-44](img/2024-11-01-14-47-44.png)

一段简单渲染器的代码来初步理解渲染器的工作

```javascript
function renderer(vnode, container) {
  // 使用 vnode.tag 作为标签名称创建 DOM 元素
  const el = document.createElement(vnode.tag)
  
  // 遍历 vnode.props，将属性、事件添加到 DOM 元素
  for(const key in vnode.props){
    if (/^on/.test(key)) {
      el.addEventListener(key.substr(2).toLowerCase(),vnode.props[key] )
    }
  }

  // 处理 children
  if (typeof vnode.children === 'string') {
    // 如果 children 是字符串，说明它是元素的文本子节点
    el.appendChild(document.createTextNode(vnode.children))
  }else if (Array.isArray(vnode.children)) {
    // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点
    vnode.children.forEach(child => renderer(child, el))
  }

  // 将元素添加到挂载点下
  container.appendChild(el)
}
```

```javascript
export default {
  data() {/* ... */},
  methods: {
    handler: () => {/* ... */}
  },
  render(){
    return h('div', { onClick: handler }, 'click me')
  }
}
```

### 总结

Vue.js 是一个声明式的框架。声明式的好处在于，它直接描述结果，用
户不需要关注过程。Vue.js 采用模板的方式来描述 UI，但它同样支持
使用虚拟 DOM 来描述 UI。虚拟 DOM 要比模板更加灵活，但模板要
比虚拟 DOM 更加直观。

然后我们讲解了最基本的渲染器的实现。渲染器的作用是，把虚
拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚
拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染
器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会
更新需要更新的内容。后面我们会专门讲解渲染器的相关知识。

接着，我们讨论了组件的本质。组件其实就是一组虚拟 DOM 元素
的封装，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象，但
这个对象下必须要有一个函数用来产出组件要渲染的虚拟 DOM。渲染器在渲染组件时，会先获取组件要渲染的内容，即执行组件的渲染函 数并得到其返回值，
我们称之为subtree，最后再递归地调用渲染器 将 subtree 渲染出来即可。

Vue.js 的模板会被一个叫作编译器的程序编译为渲染函数，后面我 们会着重讲解编译器相关知识。
最后，编译器、渲染器都是 Vue.js 的 核心组成部分，它们共同构成一个有机的整体，不同模块之间互相配 合，进一步提升框架性能。

## 响应式系统

Vue通过数据劫持 + 观察者模式（发布订阅）来实现的响应式。

- 当读取操作发生时，将副作用函数收集到“桶”中。
- 当设置操作发生时，从“桶”中取出副作用函数并执行。

> 其中“桶”就是观察者的集合

```javascript
// 用一个全局变量存储被注册的副作用函数
let activeEffect

// 存储副作用函数的桶
const bucket = new WeakMap()

function effect(fn){
  // 当调用effect注册副作用函数时，将副作用函数fn赋值给activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 activeEffect 添加到存储副作用函数的桶中
    track(target, key)
    return target[key]
  }

  // 拦截设置操作
  set(target, key, newValue){
    target[key] = newValue
    // 把副作用函数从桶里取出并执行
    trigger(target, key)
  }
});

// 在get拦截函数内调用track函数追踪变化
function track(target, key){
  if(!activeEffect){
    return
  }
  
  let depsMap = bucket.get(target)
  if(!depsMap){
    depsMap = new Map()
    bucket.set(target, depsMap)
  }

  let deps = depsMap.get(key)
  if(!deps){
    deps = new set()
    depsMap.set(key, deps)
  }

  deps.add(activeEffect)
}

// 在set拦截函数内调用trigger函数触发变化
function trigger(target, key){
  const depsMap = bucket.get(target)
  if(!depsMap){
    return
  }

  const effects = depsMap.get(key)
  effects?.forEach(fn => fn())
}
```

观察者集合的数据结构
![2024-11-05-18-19-14](img/2024-11-05-18-19-14.png)

上面是一个简单的响应式系统的实现，还有很多种情况还要考虑，分支切换导致的冗余副作用的问题，嵌套的副作用函数的问题，响应系统的可调度性，
计算属性（computed），watch的实现。

计算属性，计算属性实际上是 一个懒执行的副作用函数。

watch，它本质上利用了副作用函 数重新执行时的可调度性。一个 watch 本身会创建一个 effect，当 这个 effect 依赖的响应式数据发生变化时，会执行该 effect 的调 度器函数，即 scheduler。

实现响应式数据要比想象中难很多，并不是单纯地拦截 get/set 操作即可。举例来说，如何拦截
for...in 循环?track 函数如何追踪拦截到的 for...in 循环? 类似的问题还有很多。除此之外，我们还应该考虑如何对数组进行代
理，Map、Set的代理。想要实现完善的响应式数据，需要深入语言规范，从语言规范中找到方法来实现各种数据拦截。

## 编译器

模版编译成渲染函数的流程

![2024-12-17-16-08-20](img/2024-12-17-16-08-20.png)

- 对模版进行词法分析和语法分析生成模版AST。

- 模版AST转换成JavaScript AST。

- 根据JavaScript AST生成JavaScript代码。

```javascript
const templateAST = parse(template)
const jsAST = transform(templateAST)
const code = generate(jsAST)
```

### 模版解析生成模版AST

解析器的入参是字符串模板，解析器会逐个读取字符串模板中的 字符，并根据一定的规则将整个字符串切割为一个个 Token。这里的 Token 可以视作词法记号。解析器是如何对模板进行切割的呢? 依据什么规则? 这就需要用到有限状态自动机。

#### 词法分析（生成Token）

> 有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机（英语：finite-state automaton，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。

![2024-12-26-16-18-45](img/2024-12-26-16-18-45.png)

```javascript
// 状态机状态
const State = {
  // 初始状态
  initial: 1,
  // 标签开始状态
  tagOpen: 2,
  // 标签名称状态
  tagName: 3,
  // 文本状态
  text: 4,
  // 结束标签状态
  tagEnd: 5,
  // 结束标签名称状态
  tagEndName: 6
}

// 一个辅助函数，用于判断是否是字母
function isAlpha(char) {
  return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z'
}

// 接收模板字符串作为参数，并将模板切割为 Token 返回
function tokenize(str) {
  // 状态机的当前状态:初始状态
  let currentState = State.initial
  // 用于缓存字符
  const chars = []
  // 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回
  const tokens = []
  // 使用 while 循环开启自动机，只要模板字符串没有被消费尽，自动机就会一直运行
  while(str) {
    const char = str[0]
    // switch 语句匹配当前状态
    switch (currentState) {
      case State.initial:
        if (char === '<') {
          // 状态机切换到标签开始状态
          currentState = State.tagOpen
          // 消费字符 <
          str = str.slice(1)
        } else if (isAlpha(char)) {
          currentState = State.text
          chars.push(char)
          str = str.slice(1)
        }
        break
      case State.tagOpen:
        if (isAlpha(char)) {
          currentState = State.tagName
          chars.push(char)
          str = str.slice(1)
        } else if (char === '/') {
          currentState = State.tagEnd
          str = str.slice(1)
        }
        break
      case State.tagName:
        if (isAlpha(char)) {
          chars.push(char)
          str = str.slice(1)
        } else if (char === '>') {
          currentState = State.initial
          // 创建一个标签 Token，并添加到 tokens 数组中
          tokens.push({
            type: 'tag',
            name: chars.join('')
          })
          chars.length = 0
          str = str.slice(1)
        }
        break
      case State.text:
        if (isAlpha(char)) {
          chars.push(char)
          str = str.slice(1)
        } else if (char === '<') {
          currentState = State.tagOpen
          tokens.push({
            type: 'text',
            content: chars.join('')
          })
          chars.length = 0
          str = str.slice(1)
        }
        break
      case State.tagEnd:
        if (isAlpha(char)) {
          currentState = State.tagEndName
          chars.push(char)
          str = str.slice(1)
        }
        break
      case State.tagEndName:
        if (isAlpha(char)) {
          chars.push(char)
          str = str.slice(1)
        } else if (char === '>') {
          currentState = State.initial
          tokens.push({
            type: 'tagEnd',
            name: chars.join('')
          })
          chars.length = 0
          str = str.slice(1)
        }
        break
    }
  }

  return tokens
}
```

```javascript
const tokens = tokenize(`<div><p>Vue</p><p>Template</p></div>`)
[
  {type: "tag", name: "div"},
  {type: "tag", name: "p"},
  {type: "text", content: "Vue"},
  {type: "tagEnd", name: "p"},
  {type: "tag", name: "p"},
  {type: "text", content: "Template"},
  {type: "tagEnd", name: "p"},
  {type: "tagEnd", name: "div"}
]
```

#### 构造AST

为Vue.js的模板构造AST是一件很简单的事。HTML是一种标记语言，它的格式非常固定，标签元素之间天然嵌套，形成父子关系。因此，一棵用于描述HTML的AST将拥有与HTML标签非常相似的
树型结构。

根据Token列表构建AST的过程，其实就是对Token列表进行扫
描的过程。在这个过程中，我们需要维护一个栈elementStack，这个栈将用于维护元素间的父子关系。每遇到一个
开始标签节点，我们就构造一个Element类型的AST节点，并将其压入栈中。类似地，每当遇到一个结束标签节点，我们就将当前栈顶
的节点弹出。这样，栈顶的节点将始终充当父节点的角色。扫描过程
中遇到的所有节点，都会作为当前栈顶节点的子节点，并添加到栈顶
节点的children属性下。

![2024-12-26-16-17-56](img/2024-12-26-16-17-56.png)

```javascript
function parse(str) {
  const tokens = tokenize(str)
  // 创建elementStack栈，起初只有Root根节点
  const root = {
    type: 'Root',
    children: []
  }
  const elementStack = [root]
  // 开启一个while循环扫描tokens，直到所有Token都被扫描完毕为止
  while (tokens.length) {
    const parent = elementStack[elementStack.length - 1]
    const t = tokens[0]
    switch (t.type) {
      case 'tag':
        // 如果当前Token是开始标签，则创建Element类型的AST节点
        const elementNode = {
          type: 'Element',
          tag: t.name,
          children: []
        }
        // 将其添加到父级节点的children中
        parent.children.push(elementNode)
        // 将当前节点压入栈
        elementStack.push(elementNode)
        break
      case 'text':
        const textNode = {
          type: 'Text',
          content: t.content
        }
        parent.children.push(textNode)
        break
      case 'tagEnd':
        // 遇到结束标签，将栈顶节点弹出
        elementStack.pop()
        break
    }
    // 消费已经扫描过的token
    tokens.shift()
  }

  return root
}
```

生成的模版AST如下

```javascript
const ast = {
  type: 'Root',
  children: [{
    type: 'Element',
    tag: 'div',
    children: [
      {
        type: 'Element',
        tag: 'p',
        children: [{
          type: 'Text',
          content: 'Vue'
        }]
      },
      {
        type: 'Element',
        tag: 'p',
        children: [{
          type: 'Text',
          content: 'Template'
        }]
      }
    ]
  }]
}
```

### 模版AST转换成JavaScript AST

![2024-12-26-16-16-16](img/2024-12-26-16-16-16.png)

```javascript
// AST工具函数-start
function createStringLiteral(value) {
  return {
    type: 'StringLiteral',
    value
  }
}

function createIdentifier(name) {
  return {
    type: 'Identifier',
    name
  }
}

function createArrayExpression(elements) {
  return {
    type: 'ArrayExpression',
    elements
  }
}

function createCallExpression(callee, arguments) {
  return {
    type: 'CallExpression',
    callee: createIdentifier(callee),
    arguments
  }
}

function transformText(node) {
  if (node.type !== 'Text') {
    return
  }

  node.jsNode = createStringLiteral(node.content)
}


function transformElement(node) {

  return () => {
    if (node.type !== 'Element') {
      return
    }

    const callExp = createCallExpression('h', [
      createStringLiteral(node.tag)
    ])
    node.children.length === 1 ?
      callExp.arguments.push(node.children[0].jsNode) :
      callExp.arguments.push(
        createArrayExpression(node.children.map(c => c.jsNode))
      )

    node.jsNode = callExp
  }
}

function transformRoot(node) {
  return () => {
    if (node.type !== 'Root') {
      return
    }

    const vnodeJSAST = node.children[0].jsNode

    node.jsNode = {
      type: 'FunctionDecl',
      id: {
        type: 'Identifier',
        name: 'render'
      },
      params: [],
      body: [{
        type: 'ReturnStatement',
        return: vnodeJSAST
      }]
    }
  }
}
// AST工具函数-end

function traverseNode(ast, context) {
  context.currentNode = ast

  const exitFns = []
  const transforms = context.nodeTransforms
  for (let i = 0; i < transforms.length; i++) {
    const onExit = transforms[i](context.currentNode, context)
    if (onExit) {
      exitFns.push(onExit)
    }
    if (!context.currentNode) return
  }

  const children = context.currentNode.children
  if (children) {
    for (let i = 0; i < children.length; i++) {
      context.parent = context.currentNode
      context.childIndex = i
      traverseNode(children[i], context)
    }
  }

  let i = exitFns.length
  // 注意，这里我们要反序执行
  while (i--) {
    exitFns[i]()
  }
}


function transform(ast) {
  const context = {
    currentNode: null,
    parent: null,
    replaceNode(node) {
      context.currentNode = node
      context.parent.children[context.childIndex] = node
    },
    removeNode() {
      if (context.parent) {
        context.parent.children.splice(context.childIndex, 1)
        context.currentNode = null
      }
    },
    nodeTransforms: [
      transformRoot,
      transformElement,
      transformText
    ]
  }
  // 调用 traverseNode 完成转换
  traverseNode(ast, context)
}
```

### 生成代码

代码生成本质上是字符串拼接的艺术。我们需要访问JavaScript AST中的节点，为每一种类型的节点生成相符的JavaScript代码。

```javascript
function generate(node) {
  const context = {
    // 存储最终生成的渲染函数代码
    code: '',
    // 在生成代码时，通过调用 push 函数完成代码的拼接
    push(code) {
      context.code += code
    },
    // 当前缩进的级别，初始值为 0，即没有缩进
    currentIndent: 0,
    // 换行
    newline() {
      context.code += '\n' + `  `.repeat(context.currentIndent)
    },
    // 缩进
    indent() {
      context.currentIndent++
      context.newline()
    },
    // 取消缩进
    deIndent() {
      context.currentIndent--
      context.newline()
    }
  }
  // 调用 genNode 函数完成代码生成的工作
  genNode(node, context)
  // 返回渲染函数代码
  return context.code
}

function genNode(node, context) {
  switch (node.type) {
    case 'FunctionDecl':
      genFunctionDecl(node, context)
      break
    case 'ReturnStatement':
      genReturnStatement(node, context)
      break
    case 'CallExpression':
      genCallExpression(node, context)
      break
    case 'StringLiteral':
      genStringLiteral(node, context)
      break
    case 'ArrayExpression':
      genArrayExpression(node, context)
      break
  }
}

function genFunctionDecl(node, context) {
  const {
    push,
    indent,
    deIndent
  } = context

  push(`function ${node.id.name} `)
  push(`(`)
  genNodeList(node.params, context)
  push(`) `)
  push(`{`)
  indent()

  node.body.forEach(n => genNode(n, context))

  deIndent()
  push(`}`)
}

function genNodeList(nodes, context) {
  const {
    push
  } = context
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i]
    genNode(node, context)
    if (i < nodes.length - 1) {
      push(', ')
    }
  }
}

function genReturnStatement(node, context) {
  const {
    push
  } = context

  push(`return `)
  genNode(node.return, context)
}

function genCallExpression(node, context) {
  const {
    push
  } = context
  const {
    callee,
    arguments: args
  } = node
  push(`${callee.name}(`)
  genNodeList(args, context)
  push(`)`)
}

function genStringLiteral(node, context) {
  const {
    push
  } = context

  push(`'${node.value}'`)
}

function genArrayExpression(node, context) {
  const {
    push
  } = context
  push('[')
  genNodeList(node.elements, context)
  push(']')
}
```

## 渲染器

