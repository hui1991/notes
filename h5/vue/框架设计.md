
# Vue框架设计

## 前言

最近读了一本书，书名叫Vue.js设计已实现（作者：霍春阳），通过这本书学习了很多，想以这本书为基础来学习Vue框架的原理。
该书内容并非“源码解读”，而是建立在作者对 Vue.js 框架设计的理解之上，以由简入繁的方式介绍如何实现 Vue.js 中的各个功能模块。

## Vue3的设计思路

Vue是一个UI框架，一个UI框架设计需要从描述，渲染，更新UI来考虑。

### 声明式UI

和声明式UI对应的命令式UI，命令式UI和声明式UI是对描述UI方式的一种划分，命令式UI在前端中就是直接操作DOM，关注过程，比如jQuery，声明式UI是描述想要UI的结果，框架会根据状态的变化自动更新UI，更容易维护。

目前理解，声明式UI其实在加了一些语法糖，来简化UI操作，声明式UI是一种趋势，目前流行的前端框架React，Vue，都是使用的声明式UI

#### Vue中声明式UI方案

- 使用与HTML标签一致的方式来描述DOM元素，如`<div></div>`
- 使用与HTML标签一致的方式来描述属性，如`<div id="app"></div>`
- 使用指令`v-bing`或者`:`来绑定动态属性，如`<div :id="dynamicedId"></div>`
- 使用指令`@`或者`v-on`来描述事件，如`<div @click='handleClick'></div>`

#### DSL（Domain-specific language）领域特定语言

DSL是针对特定应用领域的计算机语言。

Vue中的模版是一种DSL，它使用HTML结构，并通过Vue的指令（directives）和表达式（expressions）来实现数据绑定、条件渲染、事件监听等功能

### 虚拟DOM

虚拟DOM是通过javaScript对象来描述DOM结构，通过渲染器把虚拟DOM渲染成DOM，页面更新时通过对比虚拟DOM的变更来更新DOM。

虚拟DOM优势

- 页面更新时，直接操作DOM开销大，虚拟DOM可以快速的找出变化的UI，批量更新，避免频繁更新UI
- 跨平台，除了可以渲染成DOM，也可以渲染成别的平台UI

虚拟DOM难点

- 虚拟DOM的难点在于找出页面更新时变化的节点使用的diff算法

```javascript
const vnode = {
  tag: 'div',
  props: {
    onClick: () => alert('hello')
  },
  children: 'click me'
}
```

### 编译器

编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）

#### Vue中的编译器

Vue模版编译器，源代码是组件的模版，目前代码是JavaScript运行时平台上的JavaScript代码，其实就是编译成渲染函数

![2024-11-01-11-46-14](img/2024-11-01-11-46-14.png)

Vue模板编译器会首先对模板进行词法分析和语法分析，得到模版AST。接着将模版AST转换成JavaScript AST。最后根据JavaScript AST生成JavaScript代码

![2024-11-01-11-53-11](img/2024-11-01-11-53-11.png)

### 响应式编程（Reactive Programming）

响应式编程是一种编程范式，它强调数据流和变化的传播。当数据源发生变化时，系统会自动更新依赖于该数据的部分。这种自动化的更新机制，使得开发者可以更专注于数据的处理，而不用手动管理UI更新。

#### Vue的响应式系统

Vue通过数据劫持 + 观察者模式（发布订阅）来实现的响应式

### 组件

Vue 中，组件（Component）就像是一个自定义的 HTML 元素，它封装了可重用的 HTML、CSS 和 JavaScript 代码。
你可以把组件看作是一个独立的小型 Vue 实例，它拥有自己的数据、模板和生命周期。

渲染器主要负责将虚拟 DOM 渲染为真实 DOM，我们只需要使用虚拟 DOM
来描述最终呈现的内容即可。但当我们编写比较复杂的页面时，用来
描述页面结构的虚拟 DOM 的代码量会变得越来越多，或者说页面模板
会变得越来越大。这时，我们就需要组件化的能力。有了组件，我们
就可以将一个大的页面拆分为多个部分，每一个部分都可以作为单独
的组件，这些组件共同组成完整的页面。组件化的实现同样需要渲染
器的支持。

组件的作用

- 代码复用性
- 可维护性
- 可组合性
- 可测试性

组件也是通过虚拟DOM来描述的

```javascript
const MyComponent = function () {
  return{
    tag: 'div',
    props: {
      onClick: () => alert('hello')
    },
    children: 'click me'
  }
}
```

### 渲染器

渲染器用来执行渲染任务，把虚拟DOM渲染为真实的DOM元素，也是跨平台的关键

![2024-11-01-14-47-44](img/2024-11-01-14-47-44.png)

一段简单渲染器的代码来初步理解渲染器的工作

```javascript
function renderer(vnode, container) {
  // 使用 vnode.tag 作为标签名称创建 DOM 元素
  const el = document.createElement(vnode.tag)
  
  // 遍历 vnode.props，将属性、事件添加到 DOM 元素
  for(const key in vnode.props){
    if (/^on/.test(key)) {
      el.addEventListener(key.substr(2).toLowerCase(),vnode.props[key] )
    }
  }

  // 处理 children
  if (typeof vnode.children === 'string') {
    // 如果 children 是字符串，说明它是元素的文本子节点
    el.appendChild(document.createTextNode(vnode.children))
  }else if (Array.isArray(vnode.children)) {
    // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点
    vnode.children.forEach(child => renderer(child, el))
  }

  // 将元素添加到挂载点下
  container.appendChild(el)
}
```

```javascript
export default {
  data() {/* ... */},
  methods: {
    handler: () => {/* ... */}
  },
  render(){
    return h('div', { onClick: handler }, 'click me')
  }
}
```

### 总结

Vue.js 是一个声明式的框架。声明式的好处在于，它直接描述结果，用
户不需要关注过程。Vue.js 采用模板的方式来描述 UI，但它同样支持
使用虚拟 DOM 来描述 UI。虚拟 DOM 要比模板更加灵活，但模板要
比虚拟 DOM 更加直观。

然后我们讲解了最基本的渲染器的实现。渲染器的作用是，把虚
拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚
拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染
器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会
更新需要更新的内容。后面我们会专门讲解渲染器的相关知识。

接着，我们讨论了组件的本质。组件其实就是一组虚拟 DOM 元素
的封装，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象，但
这个对象下必须要有一个函数用来产出组件要渲染的虚拟 DOM。渲染器在渲染组件时，会先获取组件要渲染的内容，即执行组件的渲染函 数并得到其返回值，
我们称之为subtree，最后再递归地调用渲染器 将 subtree 渲染出来即可。

Vue.js 的模板会被一个叫作编译器的程序编译为渲染函数，后面我 们会着重讲解编译器相关知识。
最后，编译器、渲染器都是 Vue.js 的 核心组成部分，它们共同构成一个有机的整体，不同模块之间互相配 合，进一步提升框架性能。

## 响应式系统

Vue通过数据劫持 + 观察者模式（发布订阅）来实现的响应式。

- 当读取操作发生时，将副作用函数收集到“桶”中。
- 当设置操作发生时，从“桶”中取出副作用函数并执行。

> 其中“桶”就是观察者的集合


